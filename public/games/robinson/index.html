<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Робинзон — игра</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#021824" />
  <!-- Telegram WebApp SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}

    html,body{
      width:100%;height:100%;overflow:hidden;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
      background:radial-gradient(circle at top,#1b8ea5 0,#021824 45%,#010910 100%);
      color:#fff;
    }

    /* ---------- TOP UI (островной стиль) ---------- */
    #ui{
      position:absolute;top:0;left:0;right:0;
      padding:8px 10px 4px;
      display:flex;flex-direction:column;gap:4px;
      background:linear-gradient(
        to bottom,
        rgba(2,24,36,.95),
        rgba(2,24,36,.6),
        rgba(2,24,36,0)
      );
      box-shadow:0 6px 22px rgba(0,0,0,.75);
      z-index:10;pointer-events:none;
    }
    #ui-top{
      display:flex;align-items:center;justify-content:space-between;
      gap:10px;pointer-events:auto;
    }
    #logo{
      width:210px;height:50px;
      background:url('assets/logo_robinson.png') no-repeat left center/contain;
      text-indent:-9999px;overflow:hidden;flex-shrink:0;
      filter:drop-shadow(0 0 8px rgba(255,255,255,.6));
    }

    button{
      border:none;border-radius:999px;padding:6px 12px;
      font-size:14px;font-weight:600;cursor:pointer;
      background:linear-gradient(135deg,#ffb642,#ff7b2b);
      color:#ffffff;
      border:1px solid rgba(255,255,255,.18);
      box-shadow:0 0 12px rgba(0,0,0,.7);
      white-space:nowrap;
      text-shadow:0 1px 2px rgba(0,0,0,.8);
      transition:transform .08s ease,box-shadow .08s ease,filter .12s ease;
    }
    button:active{
      transform:scale(.95) translateY(1px);
      box-shadow:0 0 6px rgba(0,0,0,.6);
    }
    button:disabled{
      opacity:.45;cursor:default;
      box-shadow:none;
      filter:grayscale(.8) brightness(.7);
    }

    #auth-panel{
      display:flex;gap:6px;justify-content:flex-end;
      pointer-events:auto;padding:0 2px;flex-shrink:0;
    }

    #profile-chip{
      display:flex;
      align-items:center;
      justify-content:center;
      padding:4px 10px;
      border-radius:999px;
      background:rgba(5,45,65,.9);
      border:1px solid rgba(255,255,255,.2);
      box-shadow:0 2px 8px rgba(0,0,0,.8);
      font-size:13px;
      color:#e6fffb;
      text-shadow:0 1px 2px rgba(0,0,0,.8);
      cursor:pointer;
      max-width:130px;
    }
    #profile-chip.guest{
      border-color:rgba(255,255,255,.35);
      background:rgba(10,60,80,.95);
      color:#e7f9ff;
    }
    #profile-chip:hover{
      background:rgba(255,255,255,.06);
    }
    #profile-name{
      max-width:120px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    #menu-btn{
      width:52px;height:52px;padding:0;border-radius:50%;
      background:url('assets/btn_menu.png') center no-repeat;
      background-size:100% 100%;
      box-shadow:0 0 12px rgba(0,0,0,.9);
      font-size:0;
    }

    #stats{
      display:flex;justify-content:space-between;font-size:13px;
      text-shadow:0 1px 3px rgba(0,0,0,.7);padding:0 2px;
      color:#e4fbff;
    }
    #status-text{
      font-weight:500;
      color:#ffe7a8;
      text-shadow:0 1px 3px rgba(0,0,0,.9);
      font-size:13px;
      padding:0 2px;
    }
    #max-win-box{
      font-size:12px;
      opacity:.9;
      color:#ffefb8;
    }

    /* ---------- CANVAS + DIM ---------- */
    #canvas-container{
      position:absolute;
      inset:0;
    }
    #canvas-container::before{
      content:"";
      position:absolute;
      inset:0;
      background:radial-gradient(circle at top,rgba(255,255,255,.08),rgba(0,0,0,.25));
      pointer-events:none;
      z-index:1;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
    }

    /* ---------- SPLASH (стартовый экран только картинка) ---------- */
    #splash{
      position:fixed;inset:0;
      background:url('assets/splash_bg.png') center center / cover no-repeat;
      display:flex;align-items:center;justify-content:center;
      z-index:999;transition:opacity .6s ease;
    }
    #splash.hidden{opacity:0;pointer-events:none}
    #splash-inner{
      width:100%;max-width:360px;
      padding:24px 20px calc(24px + env(safe-area-inset-bottom));
      text-align:center;display:flex;flex-direction:column;gap:16px;
      background:transparent;border:none;box-shadow:none;
    }

    /* ---------- BOTTOM UI (табло) ---------- */
    #bottom-ui{
      position:absolute;left:0;right:0;bottom:0;
      min-height:122px;
      background:linear-gradient(
        to top,
        rgba(3,34,51,.97),
        rgba(3,34,51,.9),
        rgba(3,34,51,.78)
      );
      display:none;
      align-items:center;justify-content:space-around;
      padding:8px 10px calc(8px + env(safe-area-inset-bottom,0px));
      z-index:2000;pointer-events:auto;
      backdrop-filter:blur(16px);
      box-shadow:0 -10px 30px rgba(0,0,0,.95);
    }
    #bottom-ui,#bottom-ui *{
      color:#ffffff;
    }
    .bottom-item{
      font-size:15px;text-shadow:0 2px 4px rgba(0,0,0,.7);
      display:flex;flex-direction:column;gap:2px;pointer-events:auto;
    }
    .bottom-label{
      font-size:11px;text-transform:uppercase;
      opacity:.75;letter-spacing:.08em;
      color:#b8efff;
    }
    .bottom-value{
      font-size:18px;font-weight:700;
      color:#ffffff;
    }
    #bottom-bet,#auto-toggle,#speed-control{cursor:pointer}

    /* ---------- PLAY BUTTON ---------- */
    #start-round-btn{
      width:118px;height:118px;padding:0;border-radius:50%;
      background:url('assets/btn_play.png') center no-repeat;
      background-size:100% 100%;
      box-shadow:0 0 28px rgba(255,198,92,.95);
      font-size:0;
      position:relative;
      z-index:2;
      overflow:visible;
    }
    #start-round-btn::after{
      content:"";
      position:absolute;inset:-12px;
      border-radius:50%;
      border:2px solid rgba(255,213,112,.8);
      box-shadow:
        0 0 18px rgba(255,213,112,.9),
        0 0 32px rgba(255,198,92,.7);
      opacity:.9;
      animation:pulsePlay 1.4s infinite ease-in-out;
    }
    #start-round-btn:disabled::after{
      opacity:0;
      animation:none;
    }
    @keyframes pulsePlay{
      0%{transform:scale(1);opacity:.85;}
      50%{transform:scale(1.08);opacity:.35;}
      100%{transform:scale(1);opacity:.85;}
    }

    /* ---------- MAIN MENU (CENTERED) ---------- */
    #menu-panel{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:2500;
      background:rgba(0,0,0,.55);
      backdrop-filter:blur(12px);
    }
    #menu-panel.open{
      display:flex;
    }
    #menu-inner{
      width:80%;
      max-width:280px;
      background:radial-gradient(circle at top,#135a72,#031e2a);
      border-radius:18px;
      padding:14px 14px 12px;
      border:1px solid rgba(255,255,255,.4);
      box-shadow:
        0 0 26px rgba(0,0,0,.9),
        0 20px 40px rgba(0,0,0,1);
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    #menu-title{
      font-size:16px;
      font-weight:700;
      margin-bottom:4px;
      text-align:center;
      color:#fff;
      text-shadow:0 2px 6px rgba(0,0,0,.85);
    }
    .menu-item{
      width:100%;
      padding:10px 14px;
      border-radius:999px;
      font-size:14px;
      font-weight:600;
      border:none;
      cursor:pointer;
      background:linear-gradient(135deg,#ffd45a,#ff9b3e);
      color:#2b1800;
      text-shadow:0 1px 2px rgba(255,255,255,.6);
      box-shadow:
        0 0 14px rgba(0,0,0,.9),
        0 4px 10px rgba(0,0,0,1);
    }
    .menu-item.secondary{
      background:rgba(5,45,65,.95);
      color:#ffffff;
      text-shadow:0 1px 2px rgba(0,0,0,.8);
      box-shadow:0 2px 8px rgba(0,0,0,.9);
      border:1px solid rgba(255,255,255,.25);
    }
    #menu-close{
      margin-top:4px;
      width:100%;
      padding:7px 12px;
      border-radius:999px;
      font-size:13px;
      border:none;
      background:rgba(255,255,255,.12);
      color:#fff;
      cursor:pointer;
    }

    /* ---------- DEPOSIT & WITHDRAW & PROFILE & BET MODALS ---------- */
    #deposit-modal,
    #withdraw-modal,
    #profile-modal,
    #bet-modal{
      position:fixed;
      inset:0;
      z-index:3000;
      display:none;
      align-items:center;
      justify-content:center;
    }
    #deposit-modal.open,
    #withdraw-modal.open,
    #profile-modal.open,
    #bet-modal.open{
      display:flex;
    }
    #deposit-modal .modal-backdrop,
    #withdraw-modal .modal-backdrop,
    #profile-modal .modal-backdrop,
    #bet-modal .modal-backdrop{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,.65);
      backdrop-filter:blur(12px);
    }
    #deposit-modal .modal-dialog,
    #withdraw-modal .modal-dialog,
    #profile-modal .modal-dialog,
    #bet-modal .modal-dialog{
      position:relative;
      z-index:1;
      width:90%;
      max-width:360px;
      background:radial-gradient(circle at top,#135a72,#031e2a);
      border-radius:18px;
      padding:18px 16px 16px;
      border:1px solid rgba(255,255,255,.45);
      box-shadow:
        0 0 24px rgba(0,0,0,.9),
        0 20px 40px rgba(0,0,0,1);
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .modal-title{
      font-size:18px;
      font-weight:700;
      margin-bottom:4px;
      text-align:left;
      color:#fff;
      text-shadow:0 2px 6px rgba(0,0,0,.85);
    }
    .modal-label{
      display:flex;
      flex-direction:column;
      gap:4px;
      font-size:13px;
      color:#d1f6ff;
    }
    .modal-label input,
    .modal-label select{
      margin-top:2px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.2);
      padding:8px 12px;
      font-size:15px;
      background:rgba(2,24,36,.9);
      color:#fff;
      outline:none;
      box-shadow:0 0 0 1px rgba(0,0,0,.5);
    }
    .modal-label input:focus,
    .modal-label select:focus{
      border-color:#ffd45a;
      box-shadow:
        0 0 0 1px rgba(255,212,90,.7),
        0 0 12px rgba(255,212,90,.8);
    }
    .modal-hint{
      font-size:11px;
      line-height:1.4;
      opacity:.9;
      color:#e3fbff;
    }
    .modal-section{
      margin-top:8px;
      padding-top:8px;
      border-top:1px solid rgba(255,255,255,.12);
    }
    .modal-subtitle{
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:.08em;
      opacity:.9;
      margin-bottom:4px;
      color:#ffe9ad;
    }
    .modal-mono{
      font-family:ui-monospace,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      font-size:12px;
      word-break:break-all;
      padding:8px;
      border-radius:8px;
      background:rgba(0,0,0,.5);
      border:1px solid rgba(255,255,255,.14);
    }
    .modal-primary-btn{
      margin-top:4px;
      width:100%;
      border-radius:999px;
      padding:9px 14px;
      font-size:14px;
      font-weight:600;
      border:none;
      cursor:pointer;
      background:linear-gradient(135deg,#ffd45a,#ff9b3e);
      color:#2b1800;
      text-shadow:0 1px 2px rgba(255,255,255,.7);
      box-shadow:
        0 0 16px rgba(0,0,0,1),
        0 4px 12px rgba(0,0,0,1);
    }
    .modal-secondary-btn{
      margin-top:6px;
      width:100%;
      border-radius:999px;
      padding:7px 12px;
      font-size:13px;
      border:1px solid rgba(255,255,255,.3);
      background:rgba(2,24,36,.95);
      color:#fff;
      cursor:pointer;
    }
    .modal-close-btn{
      margin-top:6px;
      width:100%;
      border-radius:999px;
      padding:7px 12px;
      font-size:13px;
      border:none;
      background:rgba(255,255,255,.12);
      color:#fff;
      cursor:pointer;
    }
    .modal-error{
      min-height:14px;
      font-size:11px;
      color:#ff8898;
      margin-top:2px;
    }

    /* ---------- BET WHEEL ---------- */
    .bet-wheel{
      display:flex;
      gap:8px;
      overflow-x:auto;
      padding:6px 2px 4px;
      margin:4px -4px 4px;
    }
    .bet-option{
      flex:0 0 auto;
      min-width:64px;
      padding:8px 10px;
      border-radius:999px;
      text-align:center;
      font-size:14px;
      font-weight:600;
      background:rgba(2,24,36,.9);
      border:1px solid rgba(255,255,255,.18);
      box-shadow:0 2px 8px rgba(0,0,0,.8);
      cursor:pointer;
      color:#fff;
      user-select:none;
    }
    .bet-option.selected{
      background:linear-gradient(135deg,#ffd45a,#ff9b3e);
      border-color:rgba(255,255,255,.7);
      box-shadow:0 0 16px rgba(0,0,0,1);
      color:#2b1800;
      text-shadow:0 1px 2px rgba(255,255,255,.7);
    }

    /* ---------- BIG WIN POPUP ---------- */
    #bigwin-overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:2600;
      background:radial-gradient(circle at center,rgba(255,255,255,.12),rgba(0,0,0,.85));
    }
    #bigwin-overlay.show{
      display:flex;
    }
    #bigwin-inner{
      width:80%;max-width:320px;
      background:radial-gradient(circle at top,#ffe57f,#ffb347);
      border-radius:20px;
      padding:16px 14px 14px;
      text-align:center;
      box-shadow:
        0 0 30px rgba(0,0,0,1),
        0 0 60px rgba(255,210,120,.9);
      color:#3a2200;
    }
    #bigwin-title{
      font-size:20px;
      font-weight:800;
      margin-bottom:4px;
      text-shadow:0 1px 2px rgba(255,255,255,.6);
    }
    #bigwin-mult{
      font-size:18px;
      font-weight:700;
      margin-bottom:4px;
    }
    #bigwin-amount{
      font-size:22px;
      font-weight:800;
      margin-bottom:10px;
    }
    #bigwin-close{
      margin-top:4px;
      padding:6px 14px;
      border-radius:999px;
      border:none;
      background:rgba(0,0,0,.15);
      color:#3a2200;
      cursor:pointer;
      font-size:13px;
    }

  
/* ===== PULZ CLEAN UI OVERRIDES ===== */
#ui, #menu-panel { display:none !important; }
#toast{
  position:absolute;
  left:50%;
  bottom:140px;
  transform:translateX(-50%);
  max-width:min(520px, calc(100% - 24px));
  padding:10px 14px;
  border-radius:14px;
  background:rgba(2,4,12,.72);
  border:1px solid rgba(90,170,255,.18);
  box-shadow:0 0 24px rgba(60,170,255,.15);
  color:#eaf6ff;
  font-weight:700;
  letter-spacing:.02em;
  text-align:center;
  opacity:0;
  pointer-events:none;
  transition:opacity .18s ease, transform .18s ease;
}
#toast.show{ opacity:1; transform:translateX(-50%) translateY(-6px); }

#bottom-ui{
  position:absolute;left:0;right:0;bottom:0;
  z-index:2000;
  display:none;
  align-items:center;
  justify-content:center;
  padding:10px 12px calc(10px + env(safe-area-inset-bottom,0px));
  background:transparent;
}

.pulz-bar{
  width:min(560px, 100%);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:10px 12px;
  border-radius:22px;
  background:linear-gradient(180deg, rgba(6,10,18,.92), rgba(2,3,8,.92));
  border:1px solid rgba(80,160,255,.22);
  box-shadow:
    0 -18px 60px rgba(0,0,0,.85),
    0 0 22px rgba(40,140,255,.18);
  backdrop-filter: blur(16px);
}

.pulz-stat{
  min-width:92px;
  padding:10px 12px;
  border-radius:16px;
  background:rgba(7,12,22,.72);
  border:1px solid rgba(90,170,255,.18);
  box-shadow: 0 0 18px rgba(40,140,255,.10);
  user-select:none;
}
.pulz-click{ cursor:pointer; }

.pulz-label{
  font-size:10px;
  letter-spacing:.14em;
  opacity:.75;
  color:rgba(210,235,255,.95);
}

.pulz-value{
  margin-top:2px;
  font-size:18px;
  font-weight:900;
  color:#ffffff;
  text-shadow:
    0 0 10px rgba(70,170,255,.45),
    0 0 22px rgba(70,170,255,.25);
}

.pulz-pill{
  width:44px;height:44px;
  border-radius:14px;
  border:1px solid rgba(90,170,255,.22);
  background:linear-gradient(180deg, rgba(10,18,35,.9), rgba(6,10,18,.9));
  color:#eaf6ff;
  font-size:22px;
  font-weight:900;
  cursor:pointer;
  box-shadow:
    0 0 18px rgba(40,140,255,.18),
    inset 0 0 0 1px rgba(255,255,255,.05);
  transition: transform .08s ease, filter .12s ease;
}
.pulz-pill:active{ transform: scale(.96); }

.pulz-play{
  width:88px;height:88px;
  border-radius:999px;
  border:2px solid rgba(120,200,255,.55);
  background:
    radial-gradient(circle at 30% 25%, rgba(255,255,255,.22), transparent 40%),
    radial-gradient(circle at 50% 55%, rgba(60,170,255,.35), rgba(2,6,18,.95) 62%);
  box-shadow:
    0 0 28px rgba(60,170,255,.35),
    0 0 60px rgba(60,170,255,.18),
    inset 0 0 0 1px rgba(255,255,255,.06);
  cursor:pointer;
  position:relative;
  outline:none;
}
.pulz-play::before{
  content:"";
  position:absolute;
  left:52%;
  top:50%;
  transform:translate(-45%,-50%);
  width:0;height:0;
  border-top:14px solid transparent;
  border-bottom:14px solid transparent;
  border-left:22px solid rgba(235,250,255,.98);
  filter: drop-shadow(0 0 10px rgba(60,170,255,.55));
}
.pulz-play::after{
  content:"";
  position:absolute; inset:-10px;
  border-radius:999px;
  border:2px solid rgba(60,170,255,.28);
  box-shadow:0 0 26px rgba(60,170,255,.22);
  animation:pulzPulse 1.35s ease-in-out infinite;
}
.pulz-play:disabled{ opacity:.45; cursor:default; }
.pulz-play:disabled::after{ animation:none; opacity:0; }

@keyframes pulzPulse{
  0%{ transform:scale(1); opacity:.9; }
  55%{ transform:scale(1.06); opacity:.25; }
  100%{ transform:scale(1); opacity:.9; }
}

</style>
</head>
<body>
  <!-- Заставка (только картинка) -->
  <div id="splash">
    <div id="splash-inner"></div>
  </div>

  
  <!-- Status toast -->
  <div id="toast" aria-live="polite"></div>
<!-- Нижний Pulz-бар -->
  <div id="bottom-ui">
    <div class="pulz-bar">
      <div class="pulz-stat">
        <div class="pulz-label">BALANCE</div>
        <div class="pulz-value" id="balance-bottom">0.00</div>
      </div>

      <button class="pulz-pill" id="bet-minus" aria-label="Bet minus">−</button>

      <div class="pulz-stat pulz-click" id="bottom-bet">
        <div class="pulz-label">BET</div>
        <div class="pulz-value" id="bet-bottom">1.00</div>
      </div>

      <button class="pulz-play" id="start-round-btn" aria-label="Play"></button>

      <div class="pulz-stat pulz-click" id="speed-control">
        <div class="pulz-label">SPEED</div>
        <div class="pulz-value" id="speed-value">Medium</div>
      </div>

      <button class="pulz-pill" id="bet-plus" aria-label="Bet plus">+</button>
    </div>
  </div>
<div class="bottom-value" id="balance-bottom">0.00</div>
    </div>

    <button id="start-round-btn">▶</button>

    <div class="bottom-item" id="bottom-bet">
      <div class="bottom-label">Bet</div>
      <div class="bottom-value" id="bet-bottom">1.00</div>
    </div>

    <div class="bottom-item" id="speed-control">
      <div class="bottom-label">Speed</div>
      <div class="bottom-value" id="speed-value">Medium</div>
    </div>

    <div class="bottom-item" id="auto-toggle">
      <div class="bottom-label">Auto</div>
      <div class="bottom-value" id="auto-status">Off</div>
    </div>
  </div>

  <div id="canvas-container">
    <canvas id="game"></canvas>
  </div>

  <!-- Модальное окно профиля -->

  <!-- Модалка выбора ставки -->
  <div id="bet-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-dialog">
      <h2 class="modal-title">Ставка</h2>

      <div class="bet-wheel">
        <div class="bet-option" data-value="1">1</div>
        <div class="bet-option" data-value="2">2</div>
        <div class="bet-option" data-value="5">5</div>
        <div class="bet-option" data-value="10">10</div>
        <div class="bet-option" data-value="20">20</div>
        <div class="bet-option" data-value="50">50</div>
        <div class="bet-option" data-value="100">100</div>
        <div class="bet-option" data-value="200">200</div>
        <div class="bet-option" data-value="500">500</div>
        <div class="bet-option" data-value="1000">1000</div>
      </div>

      <div class="modal-hint">
        Свайпай по ставкам или нажми, чтобы выбрать.
      </div>

      <button id="bet-save" class="modal-primary-btn">Сохранить</button>
      <button id="bet-close" class="modal-close-btn">Отмена</button>
    </div>
  </div>

  <!-- BIG WIN POPUP -->
  <div id="bigwin-overlay">
    <div id="bigwin-inner">
      <div id="bigwin-title">BIG WIN</div>
      <div id="bigwin-mult">x0</div>
      <div id="bigwin-amount">0.00 RUB</div>
      <button id="bigwin-close">Продолжить</button>
    </div>
  </div>

  <script>
    const canvas=document.getElementById("game");
    const ctx=canvas.getContext("2d");

    const multiplierEl=document.getElementById("multiplier");
    const statusEl=document.getElementById("status-text");
    const toastEl=document.getElementById("toast");
    function setStatus(msg){
      if(statusEl){ statusEl.textContent = msg || ""; }
      if(toastEl){
        toastEl.textContent = msg || "";
        toastEl.classList.add("show");
        clearTimeout(setStatus._t);
        setStatus._t = setTimeout(()=>toastEl.classList.remove("show"), 1400);
      }
    }
    function safeOn(el,evt,fn){ if(el) el.addEventListener(evt,fn); }

const startBtn=document.getElementById("start-round-btn");
    const balanceEl=document.getElementById("balance");
    const balanceBottomEl=document.getElementById("balance-bottom");
    const betBottomEl=document.getElementById("bet-bottom");
const autoToggleEl=document.getElementById("auto-toggle");
    const autoStatusEl=document.getElementById("auto-status");

    const speedControlEl=document.getElementById("speed-control");
    const speedValueEl=document.getElementById("speed-value");

    const splash=document.getElementById("splash");
    const bottomUi=document.getElementById("bottom-ui");

    const menuBtn=document.getElementById("menu-btn");
    const menuPanel=document.getElementById("menu-panel");
    const menuInner=document.getElementById("menu-inner");
const menuCloseBtn=document.getElementById("menu-close");
    // Bet modal

    // Bet modal
    const betModal = document.getElementById("bet-modal");
    const betSaveBtn = document.getElementById("bet-save");
    const betCloseBtn = document.getElementById("bet-close");
    const betOptions = Array.from(document.querySelectorAll(".bet-option"));

    // Big Win overlay
    const bigwinOverlay = document.getElementById("bigwin-overlay");
    const bigwinTitleEl = document.getElementById("bigwin-title");
    const bigwinMultEl = document.getElementById("bigwin-mult");
    const bigwinAmountEl = document.getElementById("bigwin-amount");
    const bigwinCloseBtn = document.getElementById("bigwin-close");
    let currentRoundId = null;
// Скрываем заставку через 4 сек и показываем нижнее меню
    setTimeout(()=>{
      if(splash && !splash.classList.contains("hidden")){
        splash.classList.add("hidden");
      }
      if(bottomUi){
        bottomUi.style.display="flex";
      }
    },4000);

    function resizeCanvas(){
      const rect=canvas.getBoundingClientRect();
      canvas.width=rect.width*window.devicePixelRatio;
      canvas.height=rect.height*window.devicePixelRatio;
      ctx.setTransform(window.devicePixelRatio,0,0,window.devicePixelRatio,0,0);
    }
    window.addEventListener("resize",resizeCanvas);
    resizeCanvas();

    function loadImage(src){
      return new Promise((res,rej)=>{
        const img=new Image();
        img.src=src;
        img.onload=()=>res(img);
        img.onerror=rej;
      });
    }

    const assets={};
    const ASSET_LIST={
      bg:"assets/bg_ocean.png",
      rob:"assets/robinson.png",
      island:"assets/island_long.png",
      bird:"assets/bird_spritesheet.png",
      x2:"assets/bonus_x2.png",
      x3:"assets/bonus_x3.png",
      x5:"assets/bonus_x5.png",
      x10:"assets/bonus_x10.png",
      x20:"assets/bonus_x20.png",
      x50:"assets/bonus_x50.png",
      x100:"assets/bonus_x100.png",
      gameover:"assets/game_over.png",
      win:"assets/win.png"
    };

    let allLoaded=false;
    (async function preload(){
      for(const [key,src] of Object.entries(ASSET_LIST)){
        assets[key]=await loadImage(src).catch(()=>null);
      }
      allLoaded=true;
      setStatus("Готово к игре");
      await initFromCasino();
    })();

    // ==== AUDIO ====
    let audioCtx=null;
    let windNode=null;

    function getAudioCtx(){
      if(!audioCtx){
        const AC=window.AudioContext||window.webkitAudioContext;
        if(!AC) return null;
        audioCtx=new AC();
      }
      if(audioCtx.state==="suspended") audioCtx.resume();
      return audioCtx;
    }

    function playTone(freq=440,dur=.2,type="sine",vol=.4){
      const ac=getAudioCtx(); if(!ac) return;
      const osc=ac.createOscillator();
      const g=ac.createGain();
      osc.type=type;
      osc.frequency.value=freq;
      g.gain.value=vol;
      osc.connect(g);g.connect(ac.destination);
      const now=ac.currentTime;
      g.gain.setValueAtTime(0,now);
      g.gain.linearRampToValueAtTime(vol,now+0.01);
      g.gain.linearRampToValueAtTime(0.0001,now+dur);
      osc.start(now);osc.stop(now+dur+0.02);
    }
    function playChirp(f1,f2,dur,vol=.5){
      const ac=getAudioCtx(); if(!ac) return;
      const osc=ac.createOscillator();
      const g=ac.createGain();
      osc.type="sine";
      osc.frequency.setValueAtTime(f1,ac.currentTime);
      osc.frequency.linearRampToValueAtTime(f2,ac.currentTime+dur);
      g.gain.value=vol;
      osc.connect(g);g.connect(ac.destination);
      const now=ac.currentTime;
      g.gain.setValueAtTime(0,now);
      g.gain.linearRampToValueAtTime(vol,now+0.01);
      g.gain.linearRampToValueAtTime(0.0001,now+dur);
      osc.start(now);osc.stop(now+dur+0.02);
    }
    function playNoiseBurst(dur=.25,vol=.35){
      const ac=getAudioCtx(); if(!ac) return;
      const len=Math.floor(ac.sampleRate*dur);
      const buf=ac.createBuffer(1,len,ac.sampleRate);
      const data=buf.getChannelData(0);
      for(let i=0;i<len;i++) data[i]=(Math.random()*2-1)*0.9;
      const src=ac.createBufferSource();
      const g=ac.createGain();
      src.buffer=buf;src.connect(g);g.connect(ac.destination);
      const now=ac.currentTime;
      g.gain.setValueAtTime(0,now);
      g.gain.linearRampToValueAtTime(vol,now+0.02);
      g.gain.linearRampToValueAtTime(0.0001,now+dur);
      src.start(now);src.stop(now+dur+0.05);
    }

    function playWinSound(){
      playTone(880,0.18,"triangle",0.4);
      setTimeout(()=>playTone(1175,0.2,"triangle",0.45),120);
      setTimeout(()=>playTone(1320,0.25,"triangle",0.4),220);
    }
    function playBonusSound(){playChirp(700,1100,0.18,0.45);}
    function playBirdSound(){playChirp(500,260,0.16,0.45);}
    function playSplashSound(){playNoiseBurst(0.25,0.3);}
    function playWhooshSound(){playNoiseBurst(0.15,0.22);}

    function startWindSound(){
      const ac=getAudioCtx(); if(!ac) return;
      if(windNode) return;
      const len=ac.sampleRate*2;
      const buf=ac.createBuffer(1,len,ac.sampleRate);
      const data=buf.getChannelData(0);
      for(let i=0;i<len;i++){
        data[i]=(Math.random()*2-1)*0.6;
      }
      const src=ac.createBufferSource();
      const g=ac.createGain();
      src.buffer=buf;
      src.loop=true;
      g.gain.value=0.12;
      src.connect(g);g.connect(ac.destination);
      src.start();
      windNode={src,g};
    }
    function stopWindSound(){
      if(!windNode || !audioCtx) return;
      const now=audioCtx.currentTime;
      windNode.g.gain.cancelScheduledValues(now);
      windNode.g.gain.setValueAtTime(windNode.g.gain.value,now);
      windNode.g.gain.linearRampToValueAtTime(0.0001,now+0.2);
      windNode.src.stop(now+0.25);
      windNode=null;
    }

    // ==== GAME STATE ====
    let state="idle"; // idle | flying | won | lost | skid
    let robinson;
    let objects;
    let time;
    let lastTs;
    let multiplier;
    let baseBet=1;
    const betMinusBtn=document.getElementById("bet-minus");
    const betPlusBtn=document.getElementById("bet-plus");
    function clampBet(v){ const min=1, max=1000; return Math.max(min, Math.min(max, v)); }
    safeOn(betMinusBtn,"click",()=>{
      baseBet=clampBet(baseBet-1);
      if(betBottomEl) betBottomEl.textContent=baseBet.toFixed(2);
      if(typeof updateMaxWinUI==="function") updateMaxWinUI();
    });
    safeOn(betPlusBtn,"click",()=>{
      baseBet=clampBet(baseBet+1);
      if(betBottomEl) betBottomEl.textContent=baseBet.toFixed(2);
      if(typeof updateMaxWinUI==="function") updateMaxWinUI();
    });
    let userBalance=100;

    

// ==== PULZ CASINO BRIDGE ====
const PulzBridge =
  window.PULZ_GAME ||
  (window.parent && window.parent.PULZ_GAME) ||
  null;

async function initFromCasino(){
  try{
    if(!PulzBridge) throw new Error("No PulzBridge");
    const b = await PulzBridge.getBalance();
    userBalance = Number(b ?? 0);
    if(!Number.isFinite(userBalance)) userBalance = 0;
    setStatus("");
  }catch(e){
    console.warn("Casino bridge not available, demo mode:", e);
    userBalance = 100;
    setStatus("Демо-режим");
  }
  betBottomEl.textContent=baseBet.toFixed(2);
  updateBalanceUI();
  updateHistoryUI();
}

const HERO_X_REL=0.25;
    const OBJECT_SPEED_BASE = 480;
    const WATER_LINE_REL=0.8;
    const GRAVITY_BASE=75;
    let gravity=GRAVITY_BASE;

    const PLAYFIELD_TOP_REL = 0.18;
    const VIEW_OFFSET_REL=0.10;

    // Остров x2
    const ISLAND_WIDTH = 320;
    const ISLAND_HEIGHT = 90;

    let bonusPulse=0;
    let robinsonAnimTime=0;
    let cameraY=0,cameraLockY=null;

    let splashParticles=[];
    let hasSplashed=false;
    let heroVisible=true;

    let gameOverAnimTime=0,winAnimTime=0;
    let bonusParticles=[];
    let shakeTime=0;

    let floatingTexts = [];

    // Island / near-miss / skid
    let mainIsland=null;
    let islandOutcomeDecided=false; // уже решили win/near-miss/skid
    let nearMissActive=false;
    let nearMissTime=0;

    let skidActive=false;
    let skidTime=0;
    let skidDuration=0.9;
    let skidStartY=0;
    let skidEndY=0;

    // RTP (как раньше)
    let totalBet=0,totalPayout=0;
    const TARGET_RTP=0.96;
    let roundHistory=[];

    let autoPlay=false,autoRestartTimer=0;

    // Speed modes
    const SPEED_MODES = [
      {name:"Slow",   speedMul:0.75, gravityMul:0.9},
      {name:"Medium", speedMul:1.0,  gravityMul:1.0},
      {name:"Fast",   speedMul:1.3,  gravityMul:1.12},
      {name:"Turbo",  speedMul:1.7,  gravityMul:1.25}
    ];
    let speedIndex=1; // Medium

    function updateSpeedUI(){
      const m=SPEED_MODES[speedIndex];
      if(speedValueEl) speedValueEl.textContent=m.name;
    }

    function getObjectSpeed(){
      return OBJECT_SPEED_BASE * SPEED_MODES[speedIndex].speedMul;
    }
    function getGravity(){
      return GRAVITY_BASE * SPEED_MODES[speedIndex].gravityMul;
    }

    function getCurrentRTP(){
      if(totalBet<=0) return TARGET_RTP;
      return totalPayout/totalBet;
    }
    function getRTPFactor(){
      if(totalBet<50) return 1;
      const current=getCurrentRTP();
      const diff=TARGET_RTP-current;
      let factor=1+diff*0.7;
      if(factor<0.5) factor=0.5;
      if(factor>1.6) factor=1.6;
      return factor;
    }
    function updateHistoryUI(){return;}
function resetRound(){
      const w=canvas.width/window.devicePixelRatio;
      const h=canvas.height/window.devicePixelRatio;

      robinson={x:w*HERO_X_REL,y:h*0.45,vy:-170,width:65,height:65};
      gravity=getGravity();
      objects=[];
      splashParticles=[];
      hasSplashed=false;
      heroVisible=true;
      time=0;
      multiplier=1;
      lastTs=performance.now();
      bonusPulse=0;
      robinsonAnimTime=0;
      cameraY=0;cameraLockY=null;
      gameOverAnimTime=0;winAnimTime=0;
      autoRestartTimer=0;shakeTime=0;
      floatingTexts = [];

      mainIsland = {
        type:"island",
        x:w*1.18,
        y:h*WATER_LINE_REL,
        w:ISLAND_WIDTH,
        h:ISLAND_HEIGHT
      };
      objects.push(mainIsland);
      islandOutcomeDecided=false;
      nearMissActive=false;
      nearMissTime=0;
      skidActive=false;
      skidTime=0;

      multiplierEl.textContent="1.00x";

      // стартовые бонусы чуть вокруг траектории
      const baseX=w*0.55;
      const spacing=150;
      const startBonuses=["x2","x3","x5","x2","x10","x3"];
      const bonusSize=40;
      startBonuses.forEach((kind,i)=>{
        const yOffset=(Math.random()*0.12-0.06)*h;
        objects.push({
          type:"bonus",
          kind,
          x:baseX+i*spacing,
          y:robinson.y+yOffset,
          w:bonusSize,h:bonusSize,
          phase:Math.random()*Math.PI*2
        });
      });
    }
else{
        profileNameEl.textContent = "Гость";
        if(profileChip) profileChip.classList.add("guest");
      }
    }


    function updateBalanceUI(){
      if(balanceEl) balanceEl.textContent=userBalance.toFixed(2);
      if(balanceBottomEl) balanceBottomEl.textContent=userBalance.toFixed(2);
}

    // -------- МЕНЮ --------

    // -------- МЕНЮ --------
    safeOn(menuBtn, "click",e=>{
      e.stopPropagation();
      menuPanel.classList.add("open");
    });
    safeOn(menuCloseBtn, "click",()=>{
      menuPanel.classList.remove("open");
    });
    safeOn(menuPanel, "click",(e)=>{
      if(e.target === menuPanel){
        menuPanel.classList.remove("open");
      }
    });
// ---- BET MODAL ----
    function openBetModal(){
      let closest = betOptions[0];
      let minDiff = Infinity;
      betOptions.forEach(opt=>{
        const val = Number(opt.dataset.value);
        const diff = Math.abs(val - baseBet);
        opt.classList.remove("selected");
        if(diff < minDiff){
          minDiff = diff;
          closest = opt;
        }
      });
      if(closest) closest.classList.add("selected");
      betModal.classList.add("open");
    }
    function closeBetModal(){
      betModal.classList.remove("open");
    }
    betOptions.forEach(opt=>{
      opt.addEventListener("click",()=>{
        betOptions.forEach(o=>o.classList.remove("selected"));
        opt.classList.add("selected");
      });
    });
    safeOn(betSaveBtn, "click",()=>{
      const selected = betOptions.find(o=>o.classList.contains("selected"));
      if(selected){
        const v = Number(selected.dataset.value);
        if(v > 0){
          baseBet = v;
          betBottomEl.textContent = baseBet.toFixed(2);
}
      }
      closeBetModal();
    });
    safeOn(betCloseBtn, "click",()=>{
      closeBetModal();
    });
    safeOn(betModal, "click",(e)=>{
      if(e.target === betModal){
        closeBetModal();
      }
    });
    { const _bb=document.getElementById("bottom-bet"); safeOn(_bb, "click",openBetModal); }

    // ---- SPEED CONTROL ----

    // ---- SPEED CONTROL ----
    function cycleSpeed(){
      speedIndex++;
      if(speedIndex>=SPEED_MODES.length) speedIndex=0;
      updateSpeedUI();
      gravity=getGravity();
      setStatus(`Скорость: ${SPEED_MODES[speedIndex].name}`);
    }
    safeOn(speedControlEl, "click",cycleSpeed);
    updateSpeedUI();

    // ---- AUTO PLAY ----
    safeOn(autoToggleEl,"click",()=>{
      autoPlay=!autoPlay;
      if(autoStatusEl) autoStatusEl.textContent = autoPlay ? "On" : "Off";
    });

    // ---- BIG WIN POPUP ----
    function showBigWin(winAmount,mult){
      let title="BIG WIN";
      if(mult>=500) title="EPIC WIN";
      else if(mult>=250) title="ULTRA WIN";
      else if(mult>=100) title="SUPER WIN";
      else if(mult>=50) title="MEGA WIN";
      else if(mult>=25) title="BIG WIN";

      bigwinTitleEl.textContent=title;
      bigwinMultEl.textContent=`x${mult.toFixed(0)}`;
      bigwinAmountEl.textContent=`${winAmount.toFixed(2)} RUB`;
      bigwinOverlay.classList.add("show");
    }
    function hideBigWin(){
      bigwinOverlay.classList.remove("show");
    }
    safeOn(bigwinCloseBtn, "click",hideBigWin);
    safeOn(bigwinOverlay, "click",(e)=>{
      if(e.target===bigwinOverlay) hideBigWin();
    });

    // ---- ROUND CONTROL ----
    async function startRound(){
  if(!allLoaded) return;

  try {
    if (!PulzBridge) {
      setStatus("Нет связи с казино");
      return;
    }

    getAudioCtx();
    startWindSound();

    const data = await PulzBridge.placeBet(baseBet);

    currentRoundId = data.roundId || null;
    if (typeof data.balance === "number") {
      userBalance = data.balance;
      updateBalanceUI();
    }

    totalBet += baseBet;

    resetRound();
    state = "flying";
    setStatus("Робинзон в полёте...");
    startBtn.disabled = true;

  } catch (err) {
    console.error("startRound error:", err);
    setStatus("Ставка не принята");
  }
}

    safeOn(startBtn, "click",()=>{
      if(state==="idle"||state==="won"||state==="lost"){
        startRound();
      }
    });

    async function finishRound(result){
  let winAmount = 0;

  try {
    if (PulzBridge && currentRoundId) {
      const data = await PulzBridge.finishRound({
        roundId: currentRoundId,
        result,
        multiplier
      });

      if (typeof data.balance === "number") {
        userBalance = data.balance;
        updateBalanceUI();
      }
      winAmount = Number(data.win || 0);
    }
  } catch (err) {
    console.error("finishRound error:", err);
  }

  currentRoundId = null;

  if (result === "won") {
    totalPayout += winAmount;

    if(multiplier>=25){
      showBigWin(winAmount,multiplier);
    }
  }

  startBtn.disabled = false;

  const rtp = getCurrentRTP() * 100;
  console.log(`RTP (локальный): ${rtp.toFixed(1)}% (target ${(TARGET_RTP*100).toFixed(0)}%)`);
}

    // ==== SPAWN / COLLISIONS ====
    function vibrate(pattern){
      if(navigator.vibrate) navigator.vibrate(pattern);
    }

    function getLastOfType(type){
      for(let i=objects.length-1;i>=0;i--){
        if(objects[i].type===type) return objects[i];
      }
      return null;
    }

    const BONUS_WEIGHTS=[
      {key:"x2",w:40},
      {key:"x3",w:30},
      {key:"x5",w:15},
      {key:"x10",w:8},
      {key:"x20",w:4},
      {key:"x50",w:2},
      {key:"x100",w:1},
    ];
    function randomBonusKey(rtpFactor){
      const factor=rtpFactor||1;
      const ws=BONUS_WEIGHTS.map(b=>({...b}));

      for(const b of ws){
        if(["x10","x20","x50","x100"].includes(b.key)){
          b.w*=factor;
        }else{
          b.w*=(2-factor);
        }
      }

      let total=0;for(const b of ws) total+=b.w;
      let r=Math.random()*total;
      for(const b of ws){
        if(r<b.w) return b.key;
        r-=b.w;
      }
      return "x2";
    }

    function spawnBird(){
      const w=canvas.width/window.devicePixelRatio;
      const h=canvas.height/window.devicePixelRatio;
      const size=58;
      const minY=h*PLAYFIELD_TOP_REL + 20;
      const maxY=h*0.78;
      const y=minY+Math.random()*(maxY-minY);
      const x=w+size*0.8;
      const last=getLastOfType("bird");
      const minGap=90;
      if(last && last.x-x<minGap) return;
      objects.push({
        type:"bird",
        x,y,w:size,h:size,
        phase:Math.random()*Math.PI*2
      });
    }

    function spawnBonus(rtpFactor){
      const w=canvas.width/window.devicePixelRatio;
      const h=canvas.height/window.devicePixelRatio;
      const size=42;
      const minY=h*PLAYFIELD_TOP_REL + 20;
      const maxY=h*0.78;
      const y=minY+Math.random()*(maxY-minY);
      const x=w+size*0.6;
      const last=getLastOfType("bonus");
      const minGap=80;
      if(last && last.x-x<minGap) return;
      objects.push({
        type:"bonus",
        kind:randomBonusKey(rtpFactor),
        x,y,w:size,h:size,
        phase:Math.random()*Math.PI*2
      });
    }

    function isColliding(a,b){
      return !(a.x+a.w<b.x || a.x>b.x+b.w || a.y+a.h<b.y || a.y>b.y+b.h);
    }

    function createSplash(x,waterY){
      const count=22;
      for(let i=0;i<count;i++){
        const angle=Math.random()*Math.PI-Math.PI/2;
        const speed=180+Math.random()*140;
        splashParticles.push({
          x,
          y:waterY,
          vx:Math.cos(angle)*speed,
          vy:Math.sin(angle)*speed*0.8,
          life:0,
          maxLife:0.7+Math.random()*0.3,
          r:2+Math.random()*3
        });
      }
    }
    function addBonusParticles(x,y){
      const count=20;
      for(let i=0;i<count;i++){
        const ang=Math.random()*Math.PI*2;
        const sp=70+Math.random()*80;
        bonusParticles.push({
          x,y,
          vx:Math.cos(ang)*sp,
          vy:Math.sin(ang)*sp,
          life:0,
          maxLife:0.5+Math.random()*0.2
        });
      }
    }
    function spawnFloatingText(text,x,y){
      floatingTexts.push({
        text,
        x,
        y,
        life:0,
        maxLife:1.0,
        vx:0,
        vy:-40,
        alpha:1
      });
    }

    // ==== UPDATE / RENDER ====
    function update(dt){
      time+=dt;
      bonusPulse=Math.max(0,bonusPulse-dt);
      robinsonAnimTime+=dt;
      if(shakeTime>0) shakeTime=Math.max(0,shakeTime-dt);

      const w=canvas.width/window.devicePixelRatio;
      const h=canvas.height/window.devicePixelRatio;
      const waterY=h*WATER_LINE_REL;

      for(const p of splashParticles){
        p.x+=p.vx*dt;
        p.y+=p.vy*dt;
        p.vy+=350*dt;
        p.life+=dt;
      }
      splashParticles=splashParticles.filter(p=>p.life<p.maxLife);

      for(const p of bonusParticles){
        p.x+=p.vx*dt;
        p.y+=p.vy*dt;
        p.vx*=0.98;p.vy*=0.98;
        p.life+=dt;
      }
      bonusParticles=bonusParticles.filter(p=>p.life<p.maxLife);

      for(const ft of floatingTexts){
        ft.life+=dt;
        ft.y+=ft.vy*dt;
        ft.alpha=1-ft.life/ft.maxLife;
      }
      floatingTexts=floatingTexts.filter(ft=>ft.life<ft.maxLife);

      if(nearMissActive){
        nearMissTime+=dt;
        if(nearMissTime>0.6){
          nearMissActive=false;
        }
      }

      if((state==="won"||state==="lost"||state==="skid") && autoPlay){
        autoRestartTimer+=dt;
        if(autoRestartTimer>1.7 && !startBtn.disabled && userBalance>=baseBet){
          autoRestartTimer=0;startRound();return;
        }
      }

      if(state==="idle"||state==="won"){
        cameraY=-(robinson.y-h*0.55)*0.11;
        cameraLockY=null;
        if(state==="won") winAnimTime+=dt;
        return;
      }

      if(state==="lost"){
        if(cameraLockY===null) cameraLockY=cameraY;
        cameraY=cameraLockY;
        gameOverAnimTime+=dt;
        return;
      }
// === SKID MOVEMENT (скольжение по острову) ===
if (state === "skid") {

    skidTime += dt;
    let t = skidTime / skidDuration;
    if (t > 1) t = 1;

    // Робинзон медленно скользит вправо по острову
    robinson.x += 120 * dt;  // скорость вправо (можно увеличить/уменьшить)

    // Робинзон плавно опускается вниз, к воде
    robinson.y = skidStartY + (skidEndY - skidStartY) * t;

    // Когда дошёл до конца острова → выпадает в воду
    if (t >= 1) {
        state = "lost";
        heroVisible = false;
        createSplash(robinson.x, canvas.height * WATER_LINE_REL);
        finishRound("lost");
        playSplashSound();
        vibrate(180);
        return;
    }

    // Камера во время скольжения продолжает следить
    cameraY = -(robinson.y - canvas.height * 0.55) * 0.1;

    return; // важный return
}

      if(state==="skid"){
        skidTime+=dt;
        const t=Math.min(skidTime/skidDuration,1);
        const ease=1-Math.pow(1-t,2);
        robinson.y=skidStartY+(skidEndY-skidStartY)*ease;
        cameraY=-(robinson.y-h*0.55)*0.11;
        if(t>=1){
          state="lost";
          heroVisible=false;
          createSplash(robinson.x,waterY);
          playSplashSound();
          vibrate(220);
          finishRound("lost");
          stopWindSound();
        }
        return;
      }

      // ---- FLYING ----
      let timeScale=nearMissActive?0.35:1;
      const speed = getObjectSpeed();

      robinson.vy+=gravity*dt*timeScale;
      robinson.y+=robinson.vy*dt*timeScale;

      const topLimit=h*PLAYFIELD_TOP_REL;
      if(robinson.y<topLimit){
        robinson.y=topLimit;
        if(robinson.vy<0) robinson.vy=0;
      }

      const heroX=robinson.x;

      const dx=speed*dt*timeScale;
      objects.forEach(o=>{o.x-=dx;});

      const rtpFactor=getRTPFactor();

      // Частота: птицы/бонусы, без новых островов
      const birdProb  = 0.18 * 6 * rtpFactor;
      const bonusProb = 0.22 * 6 * rtpFactor;
// === FIX: регулярный спавн островов ===
function spawnIsland() {
    const w = canvas.width / window.devicePixelRatio;
    const h = canvas.height / window.devicePixelRatio;

    const islandX = w + 280;   // чтобы всегда появлялся впереди
    const islandY = h * WATER_LINE_REL;

    const islandObj = {
        type: "island",
        x: islandX,
        y: islandY,
        w: ISLAND_WIDTH,
        h: ISLAND_HEIGHT
    };

    objects.push(islandObj);
    mainIsland = islandObj;
    islandOutcomeDecided = false;
}

// вызов спавна острова
if (!mainIsland || mainIsland.x < -300) {
    spawnIsland();
}

      if(Math.random()<birdProb)  spawnBird();
      if(Math.random()<bonusProb) spawnBonus(rtpFactor);

      // Коллизии (кроме острова — его отдельно)
      const heroBox={
        x:robinson.x-robinson.width*0.45,
        y:robinson.y-robinson.height*0.45,
        w:robinson.width*0.9,
        h:robinson.height*0.9
      };

      for(const o of objects){
        if(o.type==="island") continue; // отдельно

        const ow=o.type==="bonus"?o.w*1.1:o.w*0.8;
        const oh=o.type==="bonus"?o.h*1.1:o.h*0.8;
        const box={x:o.x-ow/2,y:o.y-oh/2,w:ow,h:oh};
        if(!isColliding(heroBox,box)) continue;

        if(o.type==="bird"){
          multiplier=Math.max(multiplier*0.25,0.25);
          multiplierEl.textContent=multiplier.toFixed(2)+"x";
          setStatus("Птица! Множитель сильно снижен");
          gravity=Math.min(getGravity()*1.4,GRAVITY_BASE*3);
          robinson.vy+=60;
          o._dead=true;
          playBirdSound();
          shakeTime=0.25;
          vibrate(120);
        }
        if(o.type==="bonus"){
          const val=parseInt(o.kind.slice(1));
          multiplier*=val;
          multiplierEl.textContent=multiplier.toFixed(2)+"x";
          setStatus("Бонус "+o.kind+"!");
          robinson.vy=-200;
          gravity=Math.max(getGravity()*0.85,GRAVITY_BASE*0.7);
          bonusPulse=0.25;
          addBonusParticles(o.x,o.y);
          spawnFloatingText(o.kind.toUpperCase(), robinson.x + 70, robinson.y - 40);
          o._dead=true;
          playBonusSound();
          vibrate(80);
        }
      }
      objects=objects.filter(o=>o.x+o.w>-80 && !o._dead);

        // ---- ISLAND OUTCOME ----
      if (mainIsland && !islandOutcomeDecided) {

        const islandTop   = mainIsland.y - mainIsland.h / 2;
        const heroBottom  = robinson.y + robinson.height / 2;

        // Робинзон должен быть недалеко над островом по высоте
        const verticalClose = heroBottom >= islandTop - robinson.height * 0.4;

        // ✅ Новая логика по X: герой в пределах ширины острова
        const horizontalClose = Math.abs(mainIsland.x - heroX) <= mainIsland.w * 0.45;

        if (horizontalClose && verticalClose) {
          islandOutcomeDecided = true;

          const r = Math.random();
          // ~30% чистая победа, ~15% скольжение, ~40% near-miss, остальное обычный слив
          if (r < 0.3) {
            // Win
            state = "won";
            setStatus("Победа! Робинзон приземлился на остров");
            winAnimTime = 0;
            finishRound("won");
            playWinSound();
            vibrate([80,60,80]);
            stopWindSound();
          } else if (r < 0.45) {
            // SKID — скольжение в воду
            skidActive = true;
            state = "skid";
            skidTime = 0;
            skidDuration = 1.0;
            skidStartY = robinson.y - 20;
            skidEndY = waterY - robinson.height * 0.3;
            setStatus("Почти приземлился... и соскользнул!");
            playWhooshSound();
            vibrate([60,60,120]);
          } else if (r < 0.85) {
            // NEAR MISS — рядом с островом
            nearMissActive = true;
            nearMissTime = 0;
            setStatus("Почти попал! Совсем рядом с островом");
            playWhooshSound();
            vibrate(60);
          } else {
            // обычный слив — просто пролетел и упадёт позже
          }
        }
      }


      // ---- FALL OUT (no water) ----
      if (robinson.y - robinson.height / 2 > h + 80) {
        state = "lost";
        setStatus("Робинзон сорвался вниз");
        if(startBtn) startBtn.disabled = false;

        heroVisible = false;
        finishRound("lost");
        gameOverAnimTime = 0;
        playSplashSound();
        vibrate(180);
        stopWindSound();
        return;
      }


      cameraY=-(robinson.y-h*0.55)*0.11;
      cameraLockY=null;
    }

    function drawBackground(){
      const bg=assets.bg;
      const w=canvas.width/window.devicePixelRatio;
      const h=canvas.height/window.devicePixelRatio;
      const viewOffsetY=-h*VIEW_OFFSET_REL;
      if(bg){
        const scale=h/bg.height;
        const imgW=bg.width*scale;
        for(let x=0;x<w+imgW;x+=imgW){
          ctx.drawImage(bg,x,cameraY+viewOffsetY*0.3,imgW,h);
        }
      }else{
        const g=ctx.createLinearGradient(0,0,0,h);
        g.addColorStop(0,"#59d3ff");
        g.addColorStop(0.4,"#29a0d7");
        g.addColorStop(1,"#015471");
        ctx.fillStyle=g;
        ctx.fillRect(0,0,w,h);
      }
    }
      ctx.lineTo(w+40,h);
      ctx.lineTo(-40,h);
      ctx.closePath();
      const g=ctx.createLinearGradient(0,baseY,0,h);
      g.addColorStop(0,"rgba(0,180,220,.98)");
      g.addColorStop(0.4,"rgba(0,120,200,.98)");
      g.addColorStop(1,"rgba(0,50,110,1)");
      ctx.fillStyle=g;
      ctx.fill();

      ctx.globalAlpha=0.18;
      ctx.fillStyle="#ffffff";
      for(let x=0;x<w;x+=90){
        const yy=baseY-6+Math.sin(time*2+x*0.08)*3;
        ctx.fillRect(x,yy,60,2);
      }
      ctx.restore();
    }

    function drawSplash(){
      const h=canvas.height/window.devicePixelRatio;
      const viewOffsetY=-h*VIEW_OFFSET_REL;
      if(!splashParticles.length) return;
      ctx.save();
      for(const p of splashParticles){
        const alpha=1-p.life/p.maxLife;
        if(alpha<=0) continue;
        ctx.globalAlpha=alpha;
        ctx.fillStyle="rgba(230,245,255,1)";
        ctx.beginPath();
        ctx.arc(p.x,p.y+cameraY+viewOffsetY,p.r,0,Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawBonusParticles(){
      const h=canvas.height/window.devicePixelRatio;
      const viewOffsetY=-h*VIEW_OFFSET_REL;
      if(!bonusParticles.length) return;
      ctx.save();
      for(const p of bonusParticles){
        const alpha=1-p.life/p.maxLife;
        if(alpha<=0) continue;
        ctx.globalAlpha=alpha;
        ctx.fillStyle="rgba(255,230,140,1)";
        ctx.beginPath();
        ctx.arc(p.x,p.y+cameraY+viewOffsetY,2.2,0,Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawFloatingTexts(){
      const h=canvas.height/window.devicePixelRatio;
      const viewOffsetY=-h*VIEW_OFFSET_REL;
      if(!floatingTexts.length) return;
      ctx.save();
      ctx.font="bold 22px system-ui";
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      for(const ft of floatingTexts){
        if(ft.alpha<=0) continue;
        ctx.globalAlpha=ft.alpha;

        const x=ft.x;
        const y=ft.y+cameraY+viewOffsetY;

        ctx.lineWidth=3;
        ctx.strokeStyle="rgba(0,0,0,0.9)";
        ctx.strokeText(ft.text,x,y);

        ctx.fillStyle="#ffffff";
        ctx.fillText(ft.text,x,y);
      }
      ctx.restore();
    }

    function drawHero(){
      if(!heroVisible) return;
      const img=assets.rob; if(!img) return;
      const h=canvas.height/window.devicePixelRatio;
      const viewOffsetY=-h*VIEW_OFFSET_REL;
      const pulse=bonusPulse>0?(bonusPulse/0.25):0;
      const tilt=Math.sin(robinsonAnimTime*6)*0.18;
      const bobY=Math.sin(robinsonAnimTime*3)*4;
      const scale=1+0.25*pulse;

      ctx.save();
      ctx.translate(robinson.x,robinson.y+bobY+cameraY+viewOffsetY);
      ctx.rotate(tilt);
      ctx.scale(scale,scale);
      ctx.drawImage(img,-robinson.width/2,-robinson.height/2,robinson.width,robinson.height);
      ctx.restore();
    }

    function drawWinAboveHero(){
      if(!heroVisible) return;
      const h=canvas.height/window.devicePixelRatio;
      const viewOffsetY=-h*VIEW_OFFSET_REL;
      const px=robinson.x;
      const py=robinson.y+cameraY+viewOffsetY-robinson.height*0.7;
      const winNow=baseBet*multiplier;
      const text=winNow.toFixed(2)+" RUB";

      ctx.save();
      ctx.font="bold 19px system-ui";
      ctx.textAlign="center";
      ctx.textBaseline="middle";

      ctx.lineWidth=3;
      ctx.strokeStyle="rgba(0,0,0,0.9)";
      ctx.strokeText(text,px,py);

      ctx.fillStyle="#ffffff";
      ctx.fillText(text,px,py);

      ctx.restore();
    }

    function drawObjects(){
      const h=canvas.height/window.devicePixelRatio;
      const viewOffsetY=-h*VIEW_OFFSET_REL;
      for(const o of objects){
        let drawY=o.y;
        if(o.type==="bonus"||o.type==="bird"){
          const amp=o.type==="bonus"?4:6;
          const freq=o.type==="bonus"?3:2.5;
          drawY=o.y+Math.sin(time*freq+(o.phase||0))*amp;
        }
        if(o.type==="island"&&assets.island){
          ctx.drawImage(assets.island,o.x-o.w/2,o.y-o.h/2+cameraY+viewOffsetY,o.w,o.h);
        }
        if(o.type==="bonus"&&assets[o.kind]){
          ctx.drawImage(assets[o.kind],o.x-o.w/2,drawY-o.h/2+cameraY+viewOffsetY,o.w,o.h);
        }
        if(o.type==="bird"&&assets.bird){
          ctx.drawImage(assets.bird,o.x-o.w/2,drawY-o.h/2+cameraY+viewOffsetY,o.w,o.h);
        }
      }
    }

    function drawGameOverOverlay(){
      if(state!=="lost") return;
      const w=canvas.width/window.devicePixelRatio;
      const h=canvas.height/window.devicePixelRatio;
      const t=Math.min(gameOverAnimTime/0.5,1);
      const ease=1-Math.pow(1-t,3);

      ctx.save();
      ctx.globalAlpha=0.65*ease;
      ctx.fillStyle="rgba(0,0,0,1)";
      ctx.fillRect(0,0,w,h);

      const img=assets.gameover;
      ctx.globalAlpha=ease;
      if(img){
        const maxW=w*0.75,maxH=h*0.5;
        const baseScale=Math.min(maxW/img.width,maxH/img.height);
        const scale=baseScale*(0.9+0.1*ease);
        const iw=img.width*scale,ih=img.height*scale;
        const x=w/2-iw/2,y=h/2-ih/2;
        ctx.drawImage(img,x,y,iw,ih);
      }
      ctx.restore();
    }

    function drawWinOverlay(){
      if(state!=="won") return;
      const w=canvas.width/window.devicePixelRatio;
      const h=canvas.height/window.devicePixelRatio;
      const t=Math.min(winAnimTime/0.5,1);
      const ease=1-Math.pow(1-t,3);

      ctx.save();
      ctx.globalAlpha=0.55*ease;
      ctx.fillStyle="rgba(0,0,0,1)";
      ctx.fillRect(0,0,w,h);

      const img=assets.win;
      const cx=w/2,cy=h*0.32;

      ctx.globalAlpha=0.7*ease;
      const glowRadius=130;
      const grad=ctx.createRadialGradient(cx,cy,0,cx,cy,glowRadius);
      grad.addColorStop(0,"rgba(255,245,190,1)");
      grad.addColorStop(0.4,"rgba(255,210,90,0.95)");
      grad.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(cx,cy,glowRadius,0,Math.PI*2);
      ctx.fill();

      ctx.globalAlpha=0.95*ease;
      const sparkleCount=10;
      for(let i=0;i<sparkleCount;i++){
        const angle=time*1.5+(i*(Math.PI*2/sparkleCount));
        const baseR=80;
        const wobble=Math.sin(time*3+i)*8;
        const r=baseR+wobble;
        const x=cx+Math.cos(angle)*r;
        const y=cy+Math.sin(angle)*r;
        const size=3+Math.sin(time*4+i)*1.2;

        ctx.save();
        ctx.translate(x,y);
        ctx.rotate(angle*2);
        ctx.beginPath();
        ctx.moveTo(-size,0);ctx.lineTo(size,0);
        ctx.moveTo(0,-size);ctx.lineTo(0,size);
        ctx.strokeStyle="rgba(255,250,210,1)";
        ctx.lineWidth=1.2;
        ctx.stroke();
        ctx.restore();
      }

      ctx.globalAlpha=ease;
      if(img){
        const maxW=w*0.75,maxH=h*0.5;
        const baseScale=Math.min(maxW/img.width,maxH/img.height);
        const scale=baseScale*(0.9+0.12*ease);
        const iw=img.width*scale,ih=img.height*scale;
        const x=cx-iw/2,y=cy-ih/2;
        ctx.drawImage(img,x,y,iw,ih);
      }else{
        ctx.font="bold 26px system-ui";
        ctx.textAlign="center";
        ctx.textBaseline="middle";
        ctx.strokeStyle="rgba(0,0,0,.8)";
        ctx.lineWidth=4;
        ctx.strokeText("Ты победил!",cx,cy);
        ctx.fillStyle="#fff";
        ctx.fillText("Ты победил!",cx,cy);
      }
      ctx.restore();
    }

    function render(){
      const now=performance.now();
      const dt=(now-lastTs)/1000;
      lastTs=now;

      update(dt);

      const w=canvas.width/window.devicePixelRatio;
      const h=canvas.height/window.devicePixelRatio;
      ctx.clearRect(0,0,w,h);

      ctx.save();
      if(shakeTime>0){
        const t=shakeTime/0.25;
        const str=6*t;
        const sx=(Math.random()*2-1)*str;
        const sy=(Math.random()*2-1)*str;
        ctx.translate(sx,sy);
      }

      drawBackground();
      drawWaterRegion();
      drawObjects();
      drawHero();
      drawWinAboveHero();
      drawBonusParticles();
      drawSplash();
      drawFloatingTexts();
      drawGameOverOverlay();
      drawWinOverlay();

      ctx.restore();
      requestAnimationFrame(render);
    }

    lastTs=performance.now();
    resetRound();
    requestAnimationFrame(render);
  </script>
</body>
</html>
